package com.bluetoothexample;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.UUID;

import android.app.Activity;
import android.bluetooth.BluetoothDevice;
import android.bluetooth.BluetoothSocket;
import android.content.Intent;
import android.util.Log;
import android.app.IntentService;

public class ProcessingThread extends Thread {
	static String TAG = "ProcessingThread";
	public static final int NOT_READY = 0;
	public static final int CONNECTED = 1;
	public static final int POLLING_DATA = 2;
	private static final int BUFFERSIZE_DEFAULT = 256;
	private static final   long WAITFAILEDCONNECT_MS = 3000;

	private BluetoothDevice bdev = null;
	boolean bGo = false;
	BluetoothSocket sock = null;
	InputStream inp;
	OutputStream outp;
	HexDump hex;
	Activity myact;
	int id;
	byte[] buffer;
	
    public wrapperbluedev wb;
	
    public ProcessingThread(Activity parentact) {
		myact = parentact;
	}

	public void setbuffersize(int bsize) {
		buffersize = bsize;
	}

	public void SendIntentId(int myb,String myDevname) {
		LOG.v(TAG, "SendIntentId:enter");
		LOG.v(TAG, "SendIntentId:myb=" + myb);
		connectStateMarshall connState = new connectStateMarshall();

		connState.sname = myDevname;

		connState.iState = connectStateMarshall.FOUND_DEV;
		
		Intent myd = new Intent(myact, BluetoothInbound.class);
		myd.putExtra(connectStateMarshall.myobjname, connState);


		myact.startService(myd);
		LOG.v(TAG, "SendIntentId:leave");
	}

	int buffersize = BUFFERSIZE_DEFAULT;

	int iState = NOT_READY;

	public void set(BluetoothDevice mBdev, int id) {
		bdev = mBdev;
		this.id = id;
	}

	public BluetoothDevice getBluetoothDevice() {
		return bdev;
	}

	public boolean outputdata(byte[] b, int mlen) {
		boolean bres = false;
		try {
			outp.write(b);
			bres = true;
		} catch (IOException e) {
			LOG.v(TAG, e.getMessage());
			bres = false;
			e.printStackTrace();
		}
		return bres;
	}

	private static final UUID MY_UUID = UUID
			.fromString("00001101-0000-1000-8000-00805f9b34fb");

	public void signalBluetoothDeviceFound(ProcessingThread pth,
			BluetoothDevice device)
	{
		LOG.v(TAG, "signalBluetoothDeviceFound:entry:" + device.getName());
        wb.set(this.myact);
		pth.set(device, wb.getdevid() );// device == bdev now
		pth.startme();
		LOG.v(TAG, "signalBluetoothDeviceFound:kickthreadoff:" + bdev.getName());
		pth.start();
		LOG.v(TAG, "signalBluetoothDeviceFound:exit:" + bdev.getName());
	    
	}

	public boolean startme() {
		LOG.v(TAG, "starting" + bdev);
		bGo = true;
		return bGo;
	}

	public boolean stopme() {
		LOG.v(TAG, "stopping" + bdev);
		bGo = false;
		return bGo;
	}

	@Override
	public void run() {

		boolean brun = true;
		while (brun) {
			if (bGo == true) {
				if (iState == NOT_READY) {

					if (bdev != null) {
						if (connect(bdev) == true) {
							LOG.v(TAG, "connected");
							
							buffer = new byte[wb.getbuffersize()];
							 
							wb.announceme();
							iState = CONNECTED;
						} else {
							LOG.v(TAG, "notconnected");
						}
					}
					
				}

				if (iState == CONNECTED) {
					LOG.v(TAG, "getting input stream" + bdev);
					try 
					{
						
						inp = sock.getInputStream();
						LOG.v(TAG, "got the input stream" + bdev);
						wb.set(inp);
						
					} catch (IOException e) {
						LOG.v(TAG,"run:CONNECTED:input:"+e.getMessage());
						e.printStackTrace();
						SendRestart();
						return;
					}
					LOG.v(TAG, "got input stream" + bdev);
					LOG.v(TAG, "getting output stream" + bdev);
					try 
					{
					
						outp = sock.getOutputStream();
					
						wb.set(outp);
						wb.initprotocol();

					} catch (IOException e) {
						LOG.v(TAG,"run:CONNECTED:output:"+e.getMessage());
						e.printStackTrace();
						SendRestart();
						return;
					}
					if(bdev!=null)
					{
					 LOG.v(TAG, "got output stream" + bdev);
					}
					else
					{
						LOG.v(TAG, "got output stream: bdev appears to be null");	
					}
					iState = POLLING_DATA;
					
				}

				if (iState == POLLING_DATA) {
					LOG.v(TAG, "reading input stream" + bdev);
					try {

                        LOG.v(TAG,"blocking on read of bluetooth data:block 200ms:buffer.length:"+buffer.length);

                        for(int iClear=0;iClear<buffer.length;iClear++)
                        {
                        	buffer[iClear] = 0;
                        }
                        
						wb.read(buffer);
						LOG.v(TAG,"read bluetooth data");


					} catch (IOException e) {
						LOG.v(TAG,"run:POLLING_DATA:input:"+e.getMessage());
						e.printStackTrace();
						SendRestart();
						return;
					}


				}

			}

		}
	}

	public boolean connect(BluetoothDevice bDev) {
		boolean bRes = true;

		try {
			LOG.v(TAG, "gettingsock" + bDev);
			sock = bDev.createRfcommSocketToServiceRecord(MY_UUID);
			LOG.v(TAG, "gotsock" + bDev);
		} catch (IOException e) {
			LOG.v(TAG, e.getMessage());
			e.printStackTrace();
			bRes = false;
		}
		LOG.v(TAG, "created rfcomm" + bDev);
        
		try {
			LOG.v(TAG, "creating sock.connect" + bDev);
			sock.connect();
			LOG.v(TAG, "created sock.connected" + bDev);
		} catch (IOException e) {
			LOG.v(TAG, e.getMessage());
			e.printStackTrace();
			bRes = false;
			
			try {
				sleep(WAITFAILEDCONNECT_MS );
			} catch (InterruptedException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();

			}
		}

		return bRes;
	}
	private boolean bMarkedForDeath = false;
	private void setMarkedForDeath(boolean bres)
	{
		bMarkedForDeath = bres;
	}
	
	public boolean getMarkedForDeath()
	{
		return bMarkedForDeath;
	}
	public void SendRestart()
	{
		 LOG.v(TAG,"SendRestart:enter");
		 connectStateMarshall connState = new connectStateMarshall();
		 connState.sname = bdev.getName();
		 connState.iState = connectStateMarshall.RESTART_DEV;
		 setMarkedForDeath(true);
	     Intent myi = new Intent(myact,BluetoothInbound.class);
        
      	 myi.putExtra(connectStateMarshall.myobjname,connState);
		 myact.startService(myi);
		 LOG.v(TAG,"SendRestart:leave");
	}
	
	public void close()
	{
		if(sock!=null)
		{
			try {
				LOG.v(TAG,"about to close socket");
				sock.close();
				LOG.v(TAG,"the socket is closed");
			} catch (IOException e) {
				// TODO Auto-generated catch block
				LOG.v(TAG,"socket close exception");
				e.printStackTrace();
			}
		}
	}

}
