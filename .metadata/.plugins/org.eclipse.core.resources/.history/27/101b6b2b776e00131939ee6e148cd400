package com.bluetoothexample;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Set;

import com.example.tictac.LOG;

import android.app.Activity;
import android.bluetooth.BluetoothAdapter;
import android.bluetooth.BluetoothClass;
import android.bluetooth.BluetoothDevice;
import android.util.Log;

public class bluetoothconn {
	private static String TAG = "bluetoothconn";
	private static BluetoothAdapter adapter = BluetoothAdapter
			.getDefaultAdapter();
	private static boolean bOnce = true;

	/*
	 * Understanding bluetoothclass octet little endian bits 13 - 23 Reseved
	 * service class 8 - 12 major device number 2 - 7 minor number 0 - 1 Format
	 */

	int device_id;
	String deivce_name;
	int device_type;
	public static final btemsdevices[] btems = {
		new btemsdevices(btemsdevices.INJECTOR,
					btemsdevices.INJECTOR_NAME, btemsdevices.INJECTOR_DEV),
	};
	ArrayList<ProcessingThread> al = new ArrayList<ProcessingThread>();

	public bluetoothconn() {
		al.clear();
	}
	public void close()
	{
		int iLen,i;
		int idev;
		ProcessingThread kp;

		if(al!=null)
		{
			
			ProcessingThread p;
			for(i=0;i<al.size();i++)
			{
				kp = (ProcessingThread) al.get(i);
				idev = kp.wb.getdevid();
				if(idev == btemsdevices.INJECTOR_DEV)
				{
						kp.close();

				}
				
			}
		}
			
	}
	public int write(int idevSelected,byte[] b)
	{
		int iLen,i;
		int idev;
		ProcessingThread kp;
		iLen = b.length;
		if(al!=null)
		{
			
			ProcessingThread p;
			for(i=0;i<al.size();i++)
			{
				kp = (ProcessingThread) al.get(i);
				idev = kp.wb.getdevid();
				if(idev == idevSelected)
				{
					try {
						kp.wb.write(b);
					} catch (IOException e) {
						iLen = 0;
						e.printStackTrace();
					}
				}
			}
		}
		else
		{
			iLen = 0;
		}
		return iLen;
	}

	public int getGeneralDeviceClass(String sNam) {
		int j;
		int iDev = 0;
		for (j = 0; j < btems.length; j++) {
			if (sNam.startsWith(btems[j].device_name)) {
				iDev = btems[j].device_type;
			}
		}
		return iDev;
	}

	public int getSpecificDeviceClass(String sNam) {
		int j;
		int iDev = 0;
		for (j = 0; j < btems.length; j++) {
			if (sNam.startsWith(btems[j].device_name)) {
				iDev = btems[j].device_id;
			}
		}
		return iDev;
	}

	public int getGeneralDeviceClass(int i) {
		int iDev = 0, j;

		String sNam;
		sNam = getBTName(i);
		if (sNam != null) {
			iDev = getGeneralDeviceClass(sNam);
		}
		return iDev;
	}

	public int getSpecificDeviceClass(int i) {
		int iDev = 0, j;

		String sNam;
		sNam = getBTName(i);
		if (sNam != null) {
			for (j = 0; j < btems.length; j++) {
				if (btems[j].device_name.startsWith(sNam)) {
					iDev = btems[j].device_id;
				}
			}
		}
		return iDev;
	}

	public void releaseall() {
		al.clear();
	}

	public boolean bluetoothexist() {
		
		if (adapter == null) {
			return false;
		}
		return true;
	}

	private boolean bDoFindDevice = true;

	public void FindDevice(boolean bF) {
		bDoFindDevice = bF;
	}

	public void restart(String bluetoothFName) {
		Activity myact = null;
		ProcessingThread pth = null;
		LOG.v(TAG, "restart:enter");
		// we got a restart therefore go through the list and find them
		for (int i = 0; i < al.size(); i++) {
			pth = al.get(i);
			if (pth.getMarkedForDeath() == true) {
				LOG.v(TAG,"remove bluetoothdevice>"+i+"<");
				al.set(i, null);
				al.remove(i);
				break;
			}
		}

		if (pth != null) {
			LOG.v(TAG, "restart:found processthread to delete");
			myact = pth.myact;
			pth = null;
			FindDevice(true);
			LOG.v(TAG, "restart:processthread destroyed");
			// we let the thread do the work
		}
		LOG.v(TAG, "restart:leave");
	}

	private boolean DoesBTDeviceAlreadyExist(String fNameNew)
	{
		boolean bres = false;
		if(fNameNew!=null)
		{
			LOG.v(TAG,"looking for friendlyname:"+fNameNew);
			for(int i=0;i<al.size();i++)
			{
				ProcessingThread pjj;
				BluetoothDevice bT;
				pjj = al.get(i);
				bT = pjj.getBluetoothDevice();
				if(fNameNew.compareTo(bT.getName().toString()) == 0)
				{
				 LOG.v(TAG,"friendlyname already exists:"+bT.getName().toString());
				 bres = true;
				 break;	
				}
			}
			
			if(bres== false)
			{
				LOG.v(TAG,"friendlyname already exists:"+fNameNew);
			}
		}

		return bres;
	}

	public void discoveryCallback(Activity parentact) /* to be run in a thread */
	{
		ProcessingThread pth = null;
		LOG.v(TAG, "enter");
		if (bOnce == true) {
			bOnce = false;
			LOG.v(TAG, "startDiscovery");
			adapter.startDiscovery();
		}

		if (bDoFindDevice == true) {
			LOG.v(TAG, "start of loop");
			Set<BluetoothDevice> devices = adapter.getBondedDevices();
			for (BluetoothDevice device : devices) {
				LOG.v(TAG, "Found device: " + device);

				String sFriendName;

				sFriendName = device.getName();
				if (DoesBTDeviceAlreadyExist(sFriendName) != true) {
					// we need to add code here to only add devices that we understand
					switch (getSpecificDeviceClass(sFriendName)) {
					case btemsdevices.INJECTOR:
					break;
					default:
					  LOG.v(TAG,"returning:rejecting_the_addition_of>"+sFriendName+"<");
					  return;
					}
					
					LOG.v(TAG,"does_NOT_exist:ProcessThread created:sFriendName:"+sFriendName);
					// signal that we have a device
					pth = new ProcessingThread(parentact);

					wrapperbluedev wbd = null;

					al.add(pth);

					pth.SendIntentId(getGeneralDeviceClass(sFriendName),device.getName());

					int id = 0;
					switch (getSpecificDeviceClass(sFriendName)) {

						
					case btemsdevices.INJECTOR:
						id = btemsdevices.INJECTOR;
						wbd = new injectionneedle(id);
						break;	
						
					default:
						LOG.v(TAG,
								"signalBluetoothDeviceFound:no match on expected devices");
						wbd = null;
					}
					if(wbd!=null)
					{
					//	LOG.v(TAG,"cancelDiscovery");
					//	adapter.cancelDiscovery();
					//	LOG.v(TAG,"cancelledDiscovery");

						wbd.set(device.getName());
						pth.wb = wbd;
						LOG.v(TAG, "signalBluetoothDeviceFound:" + device.getName());
						pth.signalBluetoothDeviceFound(pth, device);
					}
					else
					{
						LOG.v(TAG,"unexpected device encountered");
					}

				}
				else
				{
					LOG.v(TAG,"does_exist:no ProcessThread created:sFriendName:"+sFriendName);
				}
			}

			bDoFindDevice = false;

		}
		LOG.v(TAG, "leave");
	}

	public int getBTNumConnected() {
		return al.size();
	}

	public String getBTName(int i) {
		BluetoothDevice bt;
		String name = null;
		ProcessingThread p;
		p = (ProcessingThread) al.get(i);
		if (p != null) {
			bt = p.getBluetoothDevice();
			name = bt.getName();
		}
		return name;
	}

	public BluetoothClass getBTClass(int i) {
		BluetoothDevice bt;
		BluetoothClass name = null;
		ProcessingThread p;
		p = (ProcessingThread) al.get(i);
		if (p != null) {
			bt = p.getBluetoothDevice();
			name = bt.getBluetoothClass();
		}
		return name;
	}

	public String getBTBondstateString(int i) {
		String s = "unknown";
		switch (i) {
		case BluetoothDevice.BOND_BONDED:
			s = "BOND_BONDED";
			break;
		case BluetoothDevice.BOND_BONDING:
			s = "BOND_BONDINF";
			break;
		case BluetoothDevice.BOND_NONE:
			s = "BOND_NONE";
			break;

		}
		return s;
	}

	public int getBTBondstate(int i) {
		BluetoothDevice bt;
		int bstate = 0;
		ProcessingThread p;
		p = (ProcessingThread) al.get(i);
		if (p != null) {
			bt = p.getBluetoothDevice();
			bstate = bt.getBondState();
		}
		return bstate;
	}

	public String getBTAddress(int i) {
		BluetoothDevice bt;
		String address = null;
		ProcessingThread p;
		p = (ProcessingThread) al.get(i);
		if (p != null) {
			bt = p.getBluetoothDevice();
			address = bt.getAddress();
		}
		return address;
	}

	public int getBTDescribeContents(int i) {
		BluetoothDevice bt;
		int bstate = 0;
		ProcessingThread p;
		p = (ProcessingThread) al.get(i);
		if (p != null) {
			bt = p.getBluetoothDevice();
			bstate = bt.describeContents();
		}
		return bstate;
	}

	public int getBTMajorClass(int i) {
		int imajor = -1;

		BluetoothDevice bt;

		ProcessingThread p;
		p = (ProcessingThread) al.get(i);
		if (p != null) {
			BluetoothClass btC;

			bt = p.getBluetoothDevice();
			btC = bt.getBluetoothClass();
			imajor = btC.getMajorDeviceClass();
		}

		return imajor;
	}

	public boolean putDataOut(int i, byte[] buffer, int mlen) {
		boolean bres = false;

		ProcessingThread p;
		p = (ProcessingThread) al.get(i);
		if (p != null) {
			bres = p.outputdata(buffer, mlen);
		}
		return bres;
	}

	public String getBTClassString(int i) {
		String s = null;
		ProcessingThread p;
		p = (ProcessingThread) al.get(i);
		if (p != null) {
			BluetoothDevice bt;
			BluetoothClass btc;
			bt = p.getBluetoothDevice();
			btc = bt.getBluetoothClass();
			s = btc.toString();
		}
		return s;
	}

	public String getBTMajorDeviceName(int major) {
		switch (major) {
		case BluetoothClass.Device.Major.AUDIO_VIDEO:
			return "AUDIO_VIDEO";

		case BluetoothClass.Device.Major.COMPUTER:
			return "COMPUTER";

		case BluetoothClass.Device.Major.HEALTH:
			return "HEALTH";

		case BluetoothClass.Device.Major.IMAGING:
			return "IMAGING";

		case BluetoothClass.Device.Major.MISC:
			return "MISC";

		case BluetoothClass.Device.Major.NETWORKING:
			return "NETWORKING";

		case BluetoothClass.Device.Major.PERIPHERAL:
			return "PERIPHERAL";

		case BluetoothClass.Device.Major.PHONE:
			return "PHONE";

		case BluetoothClass.Device.Major.TOY:
			return "TOY";

		case BluetoothClass.Device.Major.UNCATEGORIZED:
			return "UNCATEGORIZED";

		case BluetoothClass.Device.Major.WEARABLE:
			return "AUDIO_VIDEO";

		default:
			return "unknown!";
		}
	}

	// private String getBTMinorDeviceClass(int minor){
	// switch(minor){
	// case BluetoothClass.Device.AUDIO_VIDEO_CAMCORDER:
	//
	// return "VIDEO_CAMCORDER";
	//
	// case BluetoothClass.Device.Major.COMPUTER:
	// return "COMPUTER";
	// case BluetoothClass.Device.Major.HEALTH:
	// return "HEALTH";
	// case BluetoothClass.Device.Major.IMAGING:
	// return "IMAGING";
	// case BluetoothClass.Device.Major.MISC:
	// return "MISC";
	// case BluetoothClass.Device.Major.NETWORKING:
	// return "NETWORKING";
	// case BluetoothClass.Device.Major.PERIPHERAL:
	// return "PERIPHERAL";
	// case BluetoothClass.Device.Major.PHONE:
	// return "PHONE";
	// case BluetoothClass.Device.Major.TOY:
	// return "TOY";
	// case BluetoothClass.Device.Major.UNCATEGORIZED:
	// return "UNCATEGORIZED";
	// case BluetoothClass.Device.Major.WEARABLE:
	// return "AUDIO_VIDEO";
	// default: return "unknown!";
	// }
	// }

}
