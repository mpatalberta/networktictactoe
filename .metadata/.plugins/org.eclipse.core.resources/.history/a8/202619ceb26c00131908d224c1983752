package com.bluetoothtester;

import java.io.UnsupportedEncodingException;

import com.bluetoothexample.LOG;

public class InjectionControl {
   static final byte STX = (0x02);
   static final byte CR = (0x0d);
   static final byte ETX = (0x03);
   static final int MIN_PUMP_ADDR =(0);
   static final int MAX_PUMP_ADDR =(99);
   static final byte DEFAULT_PUMP = '*';
 
   static final byte Infusing = 'I';
   static final byte Withdrawing = 'W';
   static final byte Pumping_Program_Stopped = 'S';
   static final byte Pumping_Program_Paused  = 'P';
   static final byte Timed_Pause_Phase = 'T';
   static final byte Operational_trigger_wait = 'U';
   static final byte Purging = 'X';
   
   static final String ALARM_TYPE_PUMP_RESET = "AR";
   static final String ALARM_TYPE_PUMP_MOTOR_STALLED = "AS";
   static final String ALARM_TYPE_SAFE_MODE_TIME_OUT = "AT";
   static final String ALARM_TYPE_PUMPING_PROGRAM_ERROR = "AE";
   static final String ALARM_TYPE_PUMPING_PROGRAM_PHASE_OUT_OF_RANGE ="AO";
	   
   
   static final  byte Response_Error_From_Pump = '?';
   static final  String Command_Not_Applicable = "NA";
   static final  String Command_Data_Out_Of_Range = "OOR";
   static final  String Invalid_Communication_Received = "COM";
   static final  String Command_Ignored = "IGN";
   
   static final String Basic_Mode = "SAF0";
   static final String TAG = "injectionControl";
   
   public String model=null;
   public String version=null;
   public String serialNumber=null;
   public String toBasicPumpMore()
   {
	   String ret = null;
	  // b = STX;
	   
	   
	   return ret;
   }
   CRC16 myCRC16;
   public InjectionControl()
   {
	   myCRC16 = new CRC16();
   }
   
   // command set
   static final String Diameter = "DIA";

   
   static final String Phase_Number = "PHN";
   static final String Pump_Program_Function = "FUN";
   
   
   // pumping rate
   static final String Pumping_Rate = "RAT";
    static final String RATE_UM = "UM";
    static final String RATE_MM = "MM";
    static final String RATE_UH = "UH";
    static final String RATE_MH = "MH";
		   
   
	public enum ePumpStatus
	{
		eStatus_Unknown,
	    eStatus_Infusing,
		eStatus_Wathdrawing,
		eStatus_ProgramStopped,
		eStatus_ProgramPaused,
		eStatus_PausePhase,
		eStatus_UserWait,
		eStatus_Purging,
		eAlarm_PumpReset,
		eAlarm_Stalled,
		eAlarm_TimeOut,
		eAlarm_ProgramError,
		eAlarm_PhaseOutOfRange,
		eAlarm_Unknown,
		eStatus_CommsFault	
	};

	// responses from the pump regarding command
	// from new era - all possible errors
	public enum eCommandError
	{
		eCommandError_CommandOK,
		eCommandError_NotRecognized,
		eCommandError_NotApplicable,
		eCommandError_DataOutOfRange,
		eCommandError_InvalidPacket,
		eCommandError_Ignored,
		eCommandError_PossibleCommsFault		
	};
	
	// communication mode.
	// we used to support safe mode, but there was an inconsistency with our crc and the pump crc.
	// never resolved so we communicate in basic right now only
	public enum ePumpMode
	{
		eModeBasic,
		eModeSafe,
		eModeUnknown
	};

	// 
	public enum eCommsFaultProblem
	{
		eWrite,
		eRead,
		eNone
	};

	// Command frmo the UI
	public enum eUICommand
	{
		eUIOpen,
		eUIClose,
		eUIEnd,
		eUIQuery,
		eUINegotiate	
	};
	String status_codes = "IWSPTUXA"; 	
	public String ModeDescription(ePumpMode mode)
	{
		String ret = "Unknown";

		switch(mode)
		{
			case eModeBasic:	ret = "Basic"; break;
			case eModeSafe:	ret = "Safe"; break;
		}
		
		return ret;
	}
	
	public String ExtractDataFromSafeResponse(String msg)
	{
		// take off stx, length, crc bytes, etx	
		String ret=null;

		if (msg.length() >= 7)
		{
			ret = msg.substring(2, msg.length()-5);
		}

		return ret;
	}
	
	private ePumpMode m_mode;
	public void Mode(ePumpMode m)	
	{ 
		m_mode = m;			
	}	
	
	public void CDump()
	{		
	//	PUMPVALUES::iterator i;
		
	//	string key;
	//	string value;
		
	//	printf("Pump: %d, Mode: %s, Status: %s\n", m_address, ModeDescription(m_mode).c_str(), CPumpResponse::StatusDescription(Status()).c_str());
	/*
		for (i = m_values.begin(); i != m_values.end(); i++)
		{
			key = (*i).first;
			value = (*i).second;
			printf("%s = %s\n", key.c_str(), value.c_str());
		}
		*/
	}
	final static public int BAD_PUMP_NUMBER = -1;
	String m_command;
	public int setAddr(int iaddr)
	{
		m_address = iaddr;
		return m_address;
	}
	public int getAddr()
	{
		return m_address;
	}
	
	int m_address;
	public boolean RequiresAddress()
	{
		// if the command has a digit in the beginning of it or a * then we do not need address
		boolean ret = true;		
		if (m_address != BAD_PUMP_NUMBER)
		{
			ret = false;
		}
		else if (m_command.contains("*") != true)
		{		
			ret = false;
		}	
		
		return ret;
	}
	
	public boolean IsBurst()
	{
		boolean ret = false;
		
		int iPos;
	
		if(m_command.contains("*") == true)
		{
			iPos = m_command.indexOf("*");
			if(iPos > 1)
			{
			ret = true;
			}
		}
		return ret;
	}
	public boolean IsBroadcast()
	{
		// this just searches for a * in the beginning of the message.
		boolean ret = false;
		int iPos;
		if(m_command.contains("*") == true)
		{
			iPos = m_command.indexOf("*");
			if(iPos == 0)
			{
				ret = true;
			}
		}
		return ret;
	}
	/// implentation CRC16-CCITT
	static public int num1_crc16(final byte[] buffer) {
		// watchout here you must check what initila condition crc ishere
		
	    //int crc = 0xFFFF;
        int crc = 0x0000;
	    for (int j = 0; j < buffer.length ; j++) {
	        crc = ((crc  >>> 8) | (crc  << 8) )& 0xffff;
	        crc ^= (buffer[j] & 0xff);//byte to int, trunc sign
	        crc ^= ((crc & 0xff) >> 4);
	        crc ^= (crc << 12) & 0xffff;
	        crc ^= ((crc & 0xFF) << 5) & 0xffff;
	    }
	    crc &= 0xffff;
	    return crc;

	}
	// implementation CRC16-CCITT
    static public int num2_crc16(final byte[] bytes) 
    { 
        //int crc = 0xFFFF;          // initial value
        // watch out here you need to the initial condition here
    	int crc = 0x0000;
    	int polynomial = 0x1021;   // 0001 0000 0010 0001  (0, 5, 12) 

        // byte[] testBytes = "123456789".getBytes("ASCII");
        for (byte b : bytes) {
            for (int i = 0; i < 8; i++) {
                boolean bit = ((b   >> (7-i) & 1) == 1);
                boolean c15 = ((crc >> 15    & 1) == 1);
                crc <<= 1;
                if (c15 ^ bit) crc ^= polynomial;
             }
        }

        crc &= 0xffff;
        System.out.println("CRC16-CCITT = " + Integer.toHexString(crc));
        return crc;
    }
    public injectCommand lastCommandSent=injectCommand.UKNOWN;
    public enum injectCommand
    {
    	SAF0,
    	VER,
    	RESET,
    	SAF10,
    	BUZ1,
    	BUZ0,
    	ROM1,
    	ROM0,
    	BP1,
    	BP0,
    	DIN0,
    	DIN1,
    	PF0,
    	PF1,
    	AL0,
    	AL1,
    	STP,
    	DIS,
       	CLDINF,
    	CLDWDR,
    	DIRINF,
    	DIRWDR,
    	DIRREV,
    	DIA,
    	VOL,
    	DIR,
    	RUN,
    	TRG,
    	LOCP0,
    	LOCP1,
    	LOC0,
    	LOC1,
    	IN,
    	PHN,
    	FUNRAT,
    	FUNINC,
    	FUNDEC,
    	FUNSTP,
    	FUNJMP,
    	FUNLOP,
    	FUNPRI,
    	FUNPRL,
    	FUNLPS,
    	FUNLPE,
    	FUNPAS,
    	FUNIF,
    	FUNEVN,
    	FUNEVS,
    	FUNEVR,
    	FUNBEP,
    	FUNOUT,
    	RAT,
    	TRGFT,
    	TRGFH,
    	TRGF2,
    	TRGLE,
    	TRGST,
    	TRGT2,
    	TRGSP,
    	TRGP2,
    	
    	UKNOWN
    };
    
    class doVersion implements Processing
    {	

		public String proc(byte[] b) {
        	//	NE<model>V<n>.<n>
			String strnice="Uknone",s;
        		int v;

        		try {
					s = new String(b,"UTF-8");
					
	        		strnice  = s;
	        		v = strnice.indexOf("V");
	        		model = strnice.substring(0,v);
	                version =strnice.substring(v+1,strnice.length()); 
				} catch (UnsupportedEncodingException e) {
					// TODO Auto-generated catch block
					LOG.v(TAG,"convert byte string to ansi");
					e.printStackTrace();
				}
			return strnice;
		}
		injectCommand _ijc;
		@Override
		public injectCommand set(injectCommand ijc) {
			_ijc = ijc;
			return _ijc;
		}
		String _desc;
		@Override
		public String set(String desc) {
			_desc = desc;
			return _desc;
		}	
    }
    
    public float dis_infuse = 0;
    public float dis_withdraw = 0;
    public String dis_units = null;
    class doDis implements Processing
    {	

		public String proc(byte[] b) {
        	//	NE<model>V<n>.<n>
			String strnice="Uknone",s;
        		int v;

        		try {
        			
					s = new String(b,"UTF-8");
					int iw=-1;
					byte[] bInfuse,bWithdraw;
					bInfuse = new byte[255];
					bWithdraw = new byte[255];
					if(b[0]== 'I')
					{
						for(int i=0;i<b.length;i++)
						{
							if(b[i]== 'W')
							{
								iw = i;
							}
						}
					}
					
					if(iw!=-1)
					{
						int iE=-1;
						for(int i = 0;i<iw;i++)
						{
							bInfuse[i] = b[i+1];
						}
						
						for(int i = 0;i<b.length;i++)
						{
							
							if( (b[iw+1 + i] >= '0' ) && 
						         (b[iw+1 + i] <= '9') )
						    {
						    	bWithdraw[i] = b[iw+1+ i];
						    }
							else
							{
								iE =i;
								break;
							}
						}
						
						byte[] bUnits;
						bUnits = new byte[255];
						for(int i=0;i<b.length;i++)
						{
							bUnits[i] = b[iE + i];
						}
						
						// now convert to 
						String ss;
						
						ss = new String(bInfuse,"UTF-8");
						dis_infuse = Float.valueOf(ss);
						ss = new String(bWithdraw,"UTF-8");
						dis_withdraw = Float.valueOf(ss);
						dis_units = new String(bUnits,"UTF=8");
					}
	        		strnice  = s; 
				
        		} catch (UnsupportedEncodingException e) {
					// TODO Auto-generated catch block
					LOG.v(TAG,"convert byte string to ansi");
					e.printStackTrace();
				}
			return strnice;
		}	
		injectCommand _ijc;
		@Override
		public injectCommand set(injectCommand ijc) {
			_ijc = ijc;
			return _ijc;
		}
		String _desc;
		@Override
		public String set(String desc) {
			_desc = desc;
			return _desc;
		}		
    }   
    
    public int in_ttlLevel = 0;
    class doInteger implements Processing
    {	

		public String proc(byte[] b) {
        	//	NE<model>V<n>.<n>
			String strnice="Uknone",s;
        		int v;

        		try {
					s = new String(b,"UTF-8");
					in_ttlLevel = Integer.valueOf(s);
	        		strnice  = s; 
				} catch (UnsupportedEncodingException e) {
					// TODO Auto-generated catch block
					LOG.v(TAG,"convert byte string to ansi");
					e.printStackTrace();
				}
			return strnice;
		}	
		injectCommand _ijc;
		@Override
		public injectCommand set(injectCommand ijc) {
			_ijc = ijc;
			return _ijc;
		}
		String _desc;
		@Override
		public String set(String desc) {
			_desc = desc;
			return _desc;
		}		
    }   
    
    public float diameter = 0;
    class doDia implements Processing
    {	

		public String proc(byte[] b) {
        	//	NE<model>V<n>.<n>
			String strnice="Uknone",s;
        		int v;

        		try {
					s = new String(b,"UTF-8");
					diameter = Float.valueOf(s);
	        		strnice  = s; 
				} catch (UnsupportedEncodingException e) {
					// TODO Auto-generated catch block
					LOG.v(TAG,"convert byte string to ansi");
					e.printStackTrace();
				}
			return strnice;
		}	
		injectCommand _ijc;
		@Override
		public injectCommand set(injectCommand ijc) {
			_ijc = ijc;
			return _ijc;
		}
		String _desc;
		@Override
		public String set(String desc) {
			_desc = desc;
			return _desc;
		}		
    }
    public String phasenumber=null;
    class doPhaseNumber implements Processing
    {	

		public String proc(byte[] b) {
        	//	NE<model>V<n>.<n>
			String strnice="Uknone",s;
        		int v;

        		try {
					s = new String(b,"UTF-8");
	        		phasenumber = strnice  = s; 
				} catch (UnsupportedEncodingException e) {
					// TODO Auto-generated catch block
					LOG.v(TAG,"convert byte string to ansi");
					e.printStackTrace();
				}
			return strnice;
		}	
		injectCommand _ijc;
		@Override
		public injectCommand set(injectCommand ijc) {
			_ijc = ijc;
			return _ijc;
		}
		String _desc;
		@Override
		public String set(String desc) {
			_desc = desc;
			return _desc;
		}	
    }

    public boolean bBuz=false,bROM=false,bBp=false,bDin=false,bAl=false,bPf=false,bLoc=false,bLocp=false;
    
    class doOnOff implements Processing
    {	

		public String proc(byte[] b) {
			boolean bVal = false;
    		try {
    			String s;
				s = new String(b,"UTF-8");
				int i;
				i = Integer.valueOf(s);
        	    bVal = true;
				if(i==0)
        	   {
        		   bVal = false;
        	   }
			} catch (UnsupportedEncodingException e) {
				// TODO Auto-generated catch block
				LOG.v(TAG,"convert byte string to ansi");
				e.printStackTrace();
			}
			
			switch(this._ijc)
			{
			
			case BUZ0:
			case BUZ1:
			bBuz = bVal;
			break;
			case ROM0:
			case ROM1:
			bROM = bVal;
			break;
			case BP0:
			case BP1:
			bBp = bVal;
			break;
			
			case DIN0:
			case DIN1:
			bDin = bVal;
			break;
			case PF0:
			case PF1:
			bPf = bVal;
			break;
			case AL0:
			case AL1:
			bAl = bVal;
			break;
			
			case LOCP0:
			case LOCP1:
			bLocp = bVal;
			break;			
			case LOC0:
			case LOC1:
			bLoc = bVal;
			break;
			default:
				break;			
			
				
			}
        	//	NE<model>V<n>.<n>
			String strnice="Uknown",s;
        		int v;

        		try {
					s = new String(b,"UTF-8");
	        		strnice  = s+" ["+_desc + "]"; 
				} catch (UnsupportedEncodingException e) {
					// TODO Auto-generated catch block
					LOG.v(TAG,"convert byte string to ansi");
					e.printStackTrace();
				}
			return strnice;
		}	
		injectCommand _ijc;
		@Override
		public injectCommand set(injectCommand ijc) {
			_ijc = ijc;
			return _ijc;
		}
		String _desc;
		@Override
		public String set(String desc) {
			_desc = desc;
			return _desc;
		}		
    }
    public boolean trg_sp=false,trg_ft=false,trg_fh=false,trg_f2=false,trg_le=false,trg_st=false,trg_t2=false,trh_sp=false,trg_p2=false;
    class doTriggerSelect implements Processing
    {	

		public String proc(byte[] b) {
			boolean bVal = false;
    		try {
    			String s;
				s = new String(b,"UTF-8");
				int i;
				i = Integer.valueOf(s);
        	    bVal = true;
				if(i==0)
        	   {
        		   bVal = false;
        	   }
			} catch (UnsupportedEncodingException e) {
				// TODO Auto-generated catch block
				LOG.v(TAG,"convert byte string to ansi");
				e.printStackTrace();
			}
    		trg_sp=trg_ft=trg_fh=trg_f2=trg_le=trg_st=trg_t2=trh_sp=trg_p2=false;

			switch(this._ijc)
			{
			
			case TRGFT:
			    trg_ft = bVal;
				break;	
			case TRGFH:
				trg_fh= bVal;
			break;
			
			case TRGF2:
				trg_f2 = bVal;
			break;
			
			case TRGLE:
				trg_le = bVal;
			break;
			case TRGST:
				trg_st = bVal;
			break;
			case TRGT2:
				trg_t2 = bVal;
			break;
			
			case TRGSP:
				trg_sp = bVal;
			break;
			
			case TRGP2:
				trg_p2 = bVal;
				break;
			default:
				break;		
			
				
			}
        	//	NE<model>V<n>.<n>
			String strnice="Uknown",s;
        		int v;

        		try {
					s = new String(b,"UTF-8");
	        		strnice  = s; 
				} catch (UnsupportedEncodingException e) {
					// TODO Auto-generated catch block
					LOG.v(TAG,"convert byte string to ansi");
					e.printStackTrace();
				}
			return strnice;
		}	
		injectCommand _ijc;
		@Override
		public injectCommand set(injectCommand ijc) {
			_ijc = ijc;
			return _ijc;
		}
		String _desc;
		@Override
		public String set(String desc) {
			_desc = desc;
			return _desc;
		}		
    }
    
    
    public injectCommand getInjectCommand(String s)
    {
    	injectCommand ijc=injectCommand.UKNOWN;
    	for(int i=0;i<mc.length;i++)
    	{
    		if(s.contains(mc[i]._ijc.name()))
    		{
    			ijc = mc[i]._ijc;
    		}
    	}
    	return ijc;
    	
    }
    injectCommand pumpStatus=injectCommand.UKNOWN;
    class doFunction implements Processing
    {

		public String proc(byte[] b) {
        	//	NE<model>V<n>.<n>
			String strnice="Uknone",s;
        		int v;

        		try {
					s = new String(b,"UTF-8");
					
					switch(_ijc)
					{
// are states
					case	FUNRAT:
					case	FUNINC:
					case	FUNDEC:
					case	FUNSTP:
					case	FUNPRI:
					case	FUNLPS:
					case	FUNEVR:	
					case	FUNLPE:						
					case	FUNBEP:					
					case	FUNJMP:
					case	FUNLOP:
					strnice = this._desc;
					pumpStatus = _ijc;
					break;
// below all have data
					case	FUNPRL:
					case	FUNPAS:
					case	FUNIF:
					case	FUNEVN:
					case	FUNEVS:
					case	FUNOUT:
					strnice = "NOTIMPLEMENTED";	
					}
					
	        		
				} catch (UnsupportedEncodingException e) {
					// TODO Auto-generated catch block
					LOG.v(TAG,"convert byte string to ansi");
					e.printStackTrace();
				}
			return strnice;
		}
		injectCommand _ijc;
		@Override
		public injectCommand set(injectCommand ijc) {
			_ijc = ijc;
			return _ijc;
		}
		String _desc;
		@Override
		public String set(String desc) {
			_desc = desc;
			return _desc;
		}	
    }
    
    public interface Processing
    {
    	public String proc(byte[] b);
    	public injectCommand set(injectCommand _ijc);
    	public String set(String desc);
    }
    
    public class matchCmd
    {
    	public String _s;
    	public injectCommand _ijc;
    	public Processing _proc;
    	matchCmd(String s,injectCommand ijc,Processing proc)
    	{
    		_s = s;
    		_ijc = ijc;
            _proc = proc;
            _proc.set(_ijc);
            _proc.set(_s);
    	}

    	
    }
    
    
    public matchCmd[] mc =
    	{
    	new matchCmd("Basic mode Safe 0",injectCommand.SAF0,new doVersion()),    
    		
    	new matchCmd("Reset Injector",injectCommand.RESET,new doVersion()),
    	
    	
    	new matchCmd("Safe Mode",injectCommand.SAF10,new doVersion()),
    	
    	
    	new matchCmd("Version",injectCommand.VER,new doVersion()) ,    	
    	new matchCmd("Buzzer on",injectCommand.BUZ1,new doOnOff()),
    	new matchCmd("Buzzer off",injectCommand.BUZ0,new doOnOff()),
    	new matchCmd("ROM on",injectCommand.ROM1,new doOnOff()),
    	new matchCmd("ROM off",injectCommand.ROM0,new doOnOff()),
    	new matchCmd("Beeper on",injectCommand.BP1,new doOnOff()),
    	new matchCmd("Beeper off",injectCommand.BP0,new doOnOff()),
    	new matchCmd("Falling Edge Infuse, Rising Edge Withdraw",injectCommand.DIN0,new doOnOff()),
    	new matchCmd("Falling Edge Withdraw, Rising Edge Infuse",injectCommand.DIN1,new doOnOff()),
    	new matchCmd("Power failure mode disabled",injectCommand.PF0,new doVersion()),
    	new matchCmd("Power failure mode enabled",injectCommand.PF1,new doVersion()),
    	new matchCmd("Alarm off",injectCommand.AL0,new doOnOff()),
    	new matchCmd("Alarm on",injectCommand.AL1,new doOnOff()),
      	new matchCmd("LOC0",injectCommand.LOC0,new doOnOff()),    	
      	new matchCmd("LOC1",injectCommand.LOC1,new doOnOff()),   	
      	new matchCmd("LOCP0",injectCommand.LOCP0,new doOnOff()),
      	new matchCmd("LOCP1",injectCommand.LOCP1,new doOnOff()),     	
      	
    	new matchCmd("Stop",injectCommand.STP,new doVersion()),
    	new matchCmd("Dispense queried",injectCommand.DIS,new doDis()),
    	new matchCmd("CLDINF",injectCommand.CLDINF,new doVersion()),
    	new matchCmd("DIRINF",injectCommand.DIRINF,new doVersion()),
        new matchCmd("DIRWDR",injectCommand.DIRWDR,new doVersion()),
        new matchCmd("DIRREV",injectCommand.DIRREV,new doVersion()),
        
        new matchCmd("DIA",injectCommand.DIA,new doDia()),
        
        new matchCmd("VOL",injectCommand.VOL,new doVersion()),
        new matchCmd("DIR",injectCommand.DIR,new doVersion()),
        new matchCmd("RUN",injectCommand.RUN,new doVersion()),
       	new matchCmd("TRG",injectCommand.TRG,new doVersion()),

       	new matchCmd("IN",injectCommand.IN,new doInteger()),
       	
       	new matchCmd("Phase number of pump",injectCommand.PHN,new doPhaseNumber()),
       	new matchCmd("Pumping rate",injectCommand.FUNRAT,new doFunction()),
       	new matchCmd("Incremenet rate",injectCommand.FUNINC,new doFunction()),
       	new matchCmd("Decrement rate",injectCommand.FUNDEC,new doFunction()),
       	new matchCmd("Stop pump",injectCommand.FUNSTP,new doFunction()),
       	new matchCmd("Jump to program phase",injectCommand.FUNJMP,new doFunction()),
        new matchCmd("Lopp to previous loop start",injectCommand.FUNLOP,new doFunction()),
        new matchCmd("Program selection input",injectCommand.FUNPRI,new doFunction()),
        new matchCmd("Program selection label definition",injectCommand.FUNPRL,new doFunction()),
        new matchCmd("Loop start phase",injectCommand.FUNLPS,new doFunction()),
        new matchCmd("Loopend phase",injectCommand.FUNLPE,new doFunction()),
        new matchCmd("Pauses pump action",injectCommand.FUNPAS,new doFunction()),
        new matchCmd("TTL programm input",injectCommand.FUNIF,new doFunction()),
        new matchCmd("Set event trigger trap",injectCommand.FUNEVN,new doFunction()),
        new matchCmd("Set event trigger square wave trap",injectCommand.FUNEVS,new doFunction()),
        new matchCmd("Event trigger reset",injectCommand.FUNEVR,new doFunction()),
        new matchCmd("Sound short beep",injectCommand.FUNBEP,new doFunction()),
        new matchCmd("Program output TTL levels",injectCommand.FUNOUT,new doFunction()),
        new matchCmd("RAT",injectCommand.RAT,new doVersion()),
        
        new matchCmd("Foot switch trigger (falling edge start/stop)",injectCommand.TRGFT,new doTriggerSelect()),
        new matchCmd("Foot switch hold (falling edge start, rising edge start)",injectCommand.TRGFH,new doTriggerSelect()),
        new matchCmd("Foot switch reverse (rising edge start/stop)",injectCommand.TRGF2,new doTriggerSelect()),       
        new matchCmd("Level trigger (rising edge start, falling edge stop)",injectCommand.TRGLE,new doTriggerSelect()),
        new matchCmd("Start only trigger (falling edge start)",injectCommand.TRGST,new doTriggerSelect()),       
        new matchCmd("Start only trigger reversed (rising edge start)",injectCommand.TRGT2,new doTriggerSelect()),      
        new matchCmd("Stop only trigger (falling edge stop)",injectCommand.TRGSP,new doTriggerSelect()), 
        new matchCmd("TStop only trigger reversed (rising edge stop)",injectCommand.TRGP2,new doTriggerSelect()),         
        
    	new matchCmd("Unknown or user types command",injectCommand.UKNOWN,new doVersion())
    	};  	
      
    public byte[] BuildCmd(String s ,boolean safemode)
    {

    	byte[] b;
    	
    	String injCmdSend = null;
        int iMatched = -1;
    	String ss;
    	byte[] bs;
    	
    	iMatched = getIdFromDesc(s);    	
    	
    	
    	b = new byte[255];
    	for(int i = 0;i<b.length;i++){b[i] = 0;}
    		
    	if(iMatched!=-1)
    	{
 
    	
        ss = mc[iMatched]._ijc.toString();
        bs =  ss.getBytes();
    	if(safemode == true)
    	{
    		LOG.v(TAG,"FATAL_ERROR:SAFEMODE_NOT_SUPPORTED");
    	}
    	else
    	{
    	    for(int i=0;i<bs.length;i++)
    	    {
    	    	b[i] = bs[i];
    	    }
    	}

    	switch(mc[iMatched]._ijc)
    	{
    	case SAF0:		
    	break;
    	case VER:
    	break;
    	case RESET:
    	break;
    	case SAF10:// range 0 to 255
    	break;
    	case BUZ0:
    	break;
    	case BUZ1:
    	break;
    	case ROM1:
    	break;
    	case ROM0:
    	break;
    	case BP1:
    	break;
    	case BP0:
    	break;
    	case DIN0:
    	break;
    	case DIN1:
    	break;
    	case PF0:
    	break;
    	case PF1:
    	break;
    	case AL0:
    	break;
    	case AL1:
    	break;
    	case STP:
    	break;
    	case UKNOWN:
    	LOG.v(TAG,"unknown command attempted to be send");
    	break;
    	
    	
    	}
    	
    	}
    	else
    	{
    		LOG.v(TAG,"No match onlisted commands");
    	}
    	lastCommandSent = mc[iMatched]._ijc;
    	return b;
    }
    
    int getIdFromDesc(String s)
    {
    int iMatched;
    iMatched = -1;
	for(int i=0;i<mc.length;i++)
	{
	  if(mc[i]._s.matches(s)==true)
	  {
		  iMatched = i;
		  break;
	  }
	}
	return iMatched;
    }
    
    int getIdFromToken(String s)
    {
    int iMatched;
    iMatched = -1;
	for(int i=0;i<mc.length;i++)
	{
	  if(mc[i]._ijc.toString().matches(s)==true)
	  {
		  iMatched = i;
		  break;
	  }
	}
	return iMatched;
    }
    
    int getIdFromToken(byte[] b)
    {
    	return 0;
    }
    
    public String BuildANiceString(byte[] b,boolean safeMode)
    {
    	String strnice;

    		strnice = "FATAL_ERROR:ONLY BASIC MODE IS SUPPORTED";
    		if(safeMode==true)
    		{
    			LOG.v(TAG,strnice);
    		}
    		else
    		{
    		//<STX> <response data> <ETX>
    			if(b[0]!=STX)
    			{
    				LOG.v(TAG,"FATAL_ERROR:EXPTECTED_STX");
    				return "FATAL_ERROR:EXPTECTED_STX";
    			}
    			if(b[b.length-1]!=ETX)
    			{
    				LOG.v(TAG,"FATAL_ERROR:EXPECTED_ETX");
    				return "FATAL_ERROR:EXPECTED_ETX";
    			}
    			
    			
    			if(this.lastCommandSent == injectCommand.UKNOWN)
    			{
    				// simple strip stx and etx
    				byte[] bUnknown;
    				bUnknown = new byte[b.length - 2]; // stx and etx
    				for(int i=0;i<bUnknown.length;i++)
    				{
    					bUnknown[i] = b[i + 1];
    				}
    				try {
						strnice = new String(bUnknown,"UTF-8");
					} catch (UnsupportedEncodingException e) {
						LOG.v(TAG,"Unable to convert string");
						e.printStackTrace();
					}
    				
    			}
    			else
    			{
    			
	        		String s;
	        		// strip off STX and ETX
	        		byte[] bStrip;
	        		
	        		bStrip = new byte[b.length - 2];
	        		for(int i = 0;i<bStrip.length;i++)
	        		{
	        			bStrip[i] = b[i+1];
	        		}
	    		
		        	int i;
		            i = getIdFromToken(lastCommandSent.toString());
    			    strnice = mc[i]._proc.proc(bStrip);
    			}
    		}
    	return strnice;
    	
    }
}
